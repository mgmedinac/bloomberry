<!--
Autor: Maria Clara Medina Gomez
Proyecto: BloomBerry
Archivo: templates/widget.html
Descripción: Layout del widget del chatbot del sitio 
-->


{% load static i18n %}

<!-- Hoja de estilos del widget -->
<link rel="stylesheet" href="{% static 'css/widget.css' %}?v=3">

<!-- FAB (botón flotante con tu imagen) -->
<button id="bb-fab" aria-label="Abrir chat">
  <img src="{% static 'img/chatbot.png' %}" alt="Chat BloomBerry">
</button>

<!-- Panel del chat -->
<div id="bb-panel" role="dialog" aria-label="Chat BloomBerry" aria-modal="false">
  <div id="bb-header">
    <strong>  Asistente BloomBerry</strong>
    <button id="bb-close" aria-label="Cerrar">×</button>
  </div>

  <div id="bb-log">
    <div class="bb-bubble bb-assistant">
      <div class="bb-meta">  Asistente</div>
      ¡Hola! Cuéntame tu tipo de piel, objetivos y presupuesto.
    </div>
  </div>

  <form id="bb-form" action="{% url 'chat:send_message' %}" method="post">
    {% csrf_token %}
    <input id="bb-input" type="text" name="message" placeholder="Escribe tu duda…">
    <button id="bb-send" type="submit">Enviar</button>
  </form>
</div>

<script>
(function(){
  const fab     = document.getElementById("bb-fab");
  const panel   = document.getElementById("bb-panel");
  const log     = document.getElementById("bb-log");
  const form    = document.getElementById("bb-form");
  const input   = document.getElementById("bb-input");
  const closeBtn= document.getElementById("bb-close");
  const sendBtn = document.getElementById("bb-send");

  /* ---------- UI ---------- */
  function togglePanel(show){ panel.style.display = show ? "flex" : "none"; }
  fab.addEventListener("click", ()=> togglePanel(panel.style.display !== "flex"));
  closeBtn.addEventListener("click", ()=> togglePanel(false));

  function getCookie(name){
    const v=`; ${document.cookie}`; const p=v.split(`; ${name}=`);
    if(p.length===2) return p.pop().split(';').shift();
  }
  const csrftoken = getCookie('csrftoken');

  function addBubble(text, who){
    const b = document.createElement("div");
    b.className = "bb-bubble " + (who === "user" ? "bb-user" : "bb-assistant");
    if (who !== "user"){
      const meta = document.createElement("div");
      meta.className = "bb-meta"; meta.textContent = "Asistente";
      b.appendChild(meta);
    }
    const body = document.createElement("div");
    body.textContent = text;
    b.appendChild(body);
    log.appendChild(b);
    log.scrollTop = log.scrollHeight;
    return b;
  }

  function addTyping(){
    const b = document.createElement("div");
    b.className = "bb-bubble bb-assistant";
    const meta = document.createElement("div");
    meta.className = "bb-meta"; meta.textContent = "Asistente";
    const dots = document.createElement("div");
    dots.className = "bb-typing";
    dots.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
    b.appendChild(meta); b.appendChild(dots);
    log.appendChild(b);
    log.scrollTop = log.scrollHeight;
    return b;
  }

  /* ---------- Envío al backend ---------- */
  form.addEventListener("submit", async (e)=>{
    e.preventDefault();
    const text = (input.value || "").trim();
    if(!text) return;
    addBubble(text, "user");
    input.value = "";
    input.disabled = true; sendBtn.disabled = true;

    const typing = addTyping();

    try{
      const resp = await fetch(form.action, {
        method: "POST",
        headers: {"X-CSRFToken": csrftoken, "X-Requested-With": "XMLHttpRequest"},
        body: new URLSearchParams({message: text})
      });

      typing.remove();

      if (!resp.ok){
        const txt = await resp.text();
        addBubble(`Error ${resp.status}: ${txt.slice(0,200)}`, "assistant");
        return;
      }

      const data = await resp.json();
      if (data && data.ok){
        const b = addBubble(data.reply || "", "assistant");
        if (Array.isArray(data.products) && data.products.length){
          const wrap = document.createElement("div");
          wrap.className = "bb-products";
          for (const p of data.products){
            const a = document.createElement("a");
            a.className = "bb-chip";
            a.href = p.url || "#";
            a.textContent = p.name + (p.price ? ` ($${p.price})` : "");
            wrap.appendChild(a);
          }
          b.appendChild(wrap);
          log.scrollTop = log.scrollHeight;
        }
      } else {
        addBubble("No se pudo procesar la respuesta.", "assistant");
      }
    } catch(err){
      typing.remove();
      addBubble("Error de red. Intenta de nuevo.", "assistant");
    } finally {
      input.disabled = false; sendBtn.disabled = false; input.focus();
    }
  });

  /* ---------- Colocar por encima del footer dentro del área blanca ---------- */

  // Empuja el widget cuando el footer aparece (sea sticky/fixed o normal)
  const BASE = 0.1;  // separación mínima desde el borde inferior

  function placeWidget(){
    const footer = document.querySelector('footer, .footer, [role="contentinfo"]');

    // safe-area de móviles (iOS notch)
    const safe = Number(
      getComputedStyle(document.documentElement)
      .getPropertyValue('env(safe-area-inset-bottom, 0px)').replace('px','')
    ) || 0;

    let offsetPx = BASE + safe;

    if (footer){
      const cs = getComputedStyle(footer);
      const isSticky = cs.position === 'fixed' || cs.position === 'sticky';

      if (isSticky) {
        // footer pegado: súbelo por su altura
        offsetPx += (footer.offsetHeight || 0) + 8;
      } else {
        // footer normal: levanta el FAB cuando el footer entra en el viewport
        const r  = footer.getBoundingClientRect();
        const vh = window.innerHeight || document.documentElement.clientHeight;
        if (r.top < vh) {
          const overlap = (vh - r.top) + 4; // 8px de aire
          offsetPx += Math.max(0, overlap);
        }
      }
    }

    // No subir demasiado (máx ~40% del alto de la ventana)
    const maxLift = Math.round((window.innerHeight || 800) * 0.4);
    offsetPx = Math.min(offsetPx, BASE + maxLift);

    document.documentElement.style.setProperty('--bb-bottom-offset', offsetPx + 'px');
  }

  // Portal a <body> para evitar stacking contexts que tapen el FAB/panel
  function createsStackingContext(el){
    const cs = getComputedStyle(el);
    return (
      cs.transform !== 'none' ||
      cs.perspective !== 'none' ||
      cs.filter !== 'none' ||
      cs.backdropFilter !== 'none' ||
      cs.willChange.includes('transform') ||
      cs.contain !== 'none' ||
      cs.overflow !== 'visible'
    );
  }
  function needsPortal(node){
    let p = node.parentElement;
    while (p && p !== document.body){
      if (createsStackingContext(p)) return true;
      p = p.parentElement;
    }
    return false;
  }
  function portalizeWidget(){
    if ((needsPortal(fab) || needsPortal(panel)) && fab.parentElement !== document.body){
      document.body.appendChild(fab);
      document.body.appendChild(panel);
    }
    // z-index siempre por encima del footer
    let footerZ = 0;
    document.querySelectorAll('footer, .footer, [role="contentinfo"]').forEach(f=>{
      const zi = parseInt(getComputedStyle(f).zIndex || '0', 10) || 0;
      if (zi > footerZ) footerZ = zi;
    });
    const topZ = Math.max(footerZ + 10, 999999);
    fab.style.zIndex   = String(topZ);
    panel.style.zIndex = String(topZ);
  }

  // Listeners
  window.addEventListener('load',  ()=>{ portalizeWidget(); placeWidget(); });
  window.addEventListener('resize',()=>{ portalizeWidget(); placeWidget(); });
  window.addEventListener('scroll', placeWidget, { passive:true });
})();
</script>
